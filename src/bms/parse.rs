//! Parsing Bms from [`TokenStream`].
//!
//! Raw [String] == [lex] ==> [`TokenStream`] (in [`BmsLexOutput`]) == [parse] ==> [Bms] (in
//! [`BmsParseOutput`])

pub mod check_playing;
pub mod prompt;
pub mod token_processor;
pub mod validity;
use std::{cell::RefCell, ops::RangeInclusive, rc::Rc};

use num::BigUint;
use thiserror::Error;

use crate::{
    bms::prelude::SourceRangeMixinExt,
    diagnostics::{SimpleSource, ToAriadne},
};
use ariadne::{Color, Label, Report, ReportKind};

use crate::bms::{
    command::{
        ObjId,
        channel::{Channel, mapper::KeyLayoutMapper},
        mixin::SourceRangeMixin,
        time::{ObjTime, Track},
    },
    lex::token::TokenWithRange,
    model::Bms,
};

use self::token_processor::TokenProcessor;

/// An error occurred when parsing the [`TokenStream`].
#[derive(Debug, Clone, PartialEq, Eq, Hash, Error)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum ParseWarning {
    /// Syntax formed from the commands was invalid.
    #[error("syntax error: {0}")]
    SyntaxError(String),
    /// The object has required but not defined,
    #[error("undefined object: {0:?}")]
    UndefinedObject(ObjId),
    /// Has duplicated definition, that `prompt_handler` returned [`DuplicationWorkaround::Warn`].
    #[error("duplicating definition: {0}")]
    DuplicatingDef(ObjId),
    /// Has duplicated track object, that `prompt_handler` returned [`DuplicationWorkaround::Warn`].
    #[error("duplicating track object: {0} {1}")]
    DuplicatingTrackObj(Track, Channel),
    /// Has duplicated channel object, that `prompt_handler` returned [`DuplicationWorkaround::Warn`].
    #[error("duplicating channel object: {0} {1}")]
    DuplicatingChannelObj(ObjTime, Channel),
    /// Unexpected control flow.
    #[error("unexpected control flow")]
    UnexpectedControlFlow,
    /// [`Rng`] generated a value outside the required [`RangeInclusive`] for a random block.
    #[error("random generated value out of range: expected {expected:?}, got {actual}")]
    RandomGeneratedValueOutOfRange {
        /// The expected range of the random block.
        expected: RangeInclusive<BigUint>,
        /// The actual value generated by the [`Rng`].
        actual: BigUint,
    },
    /// [`Rng`] generated a value outside the required [`RangeInclusive`] for a switch block.
    #[error("switch generated value out of range: expected {expected:?}, got {actual}")]
    SwitchGeneratedValueOutOfRange {
        /// The expected range of the switch block.
        expected: RangeInclusive<BigUint>,
        /// The actual value generated by the [`Rng`].
        actual: BigUint,
    },
    /// Failed to convert a byte into a base-62 character `0-9A-Za-z`.
    #[error("expected id format is base 62 (`0-9A-Za-z`)")]
    OutOfBase62,
}

/// Type alias of `core::result::Result<T, ParseWarning>`
pub(crate) type Result<T> = core::result::Result<T, ParseWarning>;

/// A parse warning with position information.
pub type ParseWarningWithRange = SourceRangeMixin<ParseWarning>;

/// Bms Parse Output
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[must_use]
pub struct ParseOutput {
    /// The output Bms.
    pub bms: Bms,
    /// Warnings that occurred during parsing.
    pub parse_warnings: Vec<ParseWarningWithRange>,
}

impl Bms {
    /// Parses a token stream into [`Bms`] without AST.
    pub fn from_token_stream<
        'a,
        T: KeyLayoutMapper,
        TP: TokenProcessor,
        FTP: FnOnce(Rc<RefCell<Bms>>) -> TP,
    >(
        token_iter: impl IntoIterator<Item = &'a TokenWithRange<'a>>,
        proc_fn: FTP,
    ) -> ParseOutput {
        let bms = Self::default();
        let share = Rc::new(RefCell::new(bms));
        let mut parse_warnings: Vec<ParseWarningWithRange> = vec![];
        let proc = proc_fn(Rc::clone(&share));
        let (ranges, tokens): (Vec<_>, Vec<_>) = token_iter
            .into_iter()
            .map(|token| (token.range().clone(), token.content().clone()))
            .unzip();
        let mut tokens_slice = tokens.as_slice();
        let mut prev_len = tokens_slice.len();
        loop {
            if let Err(err) = proc.process(&mut tokens_slice) {
                parse_warnings.push(
                    err.into_wrapper_range(ranges[tokens.len() - tokens_slice.len()].clone()),
                );
            }
            if prev_len == tokens_slice.len() {
                break;
            }
            prev_len = tokens_slice.len();
        }
        std::mem::drop(proc);

        ParseOutput {
            bms: Rc::into_inner(share)
                .expect("processors must be dropped")
                .into_inner(),
            parse_warnings,
        }
    }
}

impl ToAriadne for ParseWarningWithRange {
    fn to_report<'a>(
        &self,
        src: &SimpleSource<'a>,
    ) -> Report<'a, (String, std::ops::Range<usize>)> {
        let (start, end) = self.as_span();
        let filename = src.name().to_string();
        Report::build(ReportKind::Warning, (filename.clone(), start..end))
            .with_message("parse: ".to_string() + &self.content().to_string())
            .with_label(Label::new((filename, start..end)).with_color(Color::Blue))
            .finish()
    }
}
